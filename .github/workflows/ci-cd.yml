name: Django CI/CD Pipeline

on:
  push:
    branches: [dev]
  pull_request:
    branches: [ main ]
    types: [opened, reopened, synchronize]


  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag"
        required: true
      environment:
        description: "Deployment environment"
        required: true
        default: "dev"
      dockerfile:
        description: "Dockerfile to use"
        required: true
        default: "Dockerfile"
env:
  IMAGE_NAME: "${{ secrets.DOCKER_USERNAME }}/django-app"
  PYTHON_VERSION: "3.11"
  DOCKER_CONTAINER_DEV: "django-app-Dev"
  DOCKER_CONTAINER_MAIN: "django-app-Main"

  
jobs:
  dev-ci-cd:
    if: github.ref == 'refs/heads/dev'
    runs-on: self-hosted

    steps:
      - name: Checkout dev branch
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: |
          python manage.py test

      - name: Docker login
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login \
          -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image (dev)
        run: |
          docker build -f Dockerfile \
          -t ${{ env.IMAGE_NAME }}:dev-${{ github.sha }} .


                                    
      - name: Push Docker image
        run: |
          docker tag ${{ env.IMAGE_NAME }}:dev-${{ github.sha }} ${{ env.IMAGE_NAME }}:dev-latest
          docker push ${{ env.IMAGE_NAME }}:dev-latest


      - name: Deploy to Dev Server
        run: |
            docker pull ${{ env.IMAGE_NAME }}:dev-latest
            docker rm -f ${{ env.DOCKER_CONTAINER_DEV }} 2>/dev/null || true
            CONTAINERS=$(docker ps -q --filter "publish=8000")
            if [ -n "$CONTAINERS" ]; then
             echo "Stopping containers using port 8000..."
             docker rm -f $CONTAINERS
             sleep 3
            fi
            docker run -d \
              --name ${{env.DOCKER_CONTAINER_DEV}}  \
              -p 8000:8000 \
              ${{ env.IMAGE_NAME }}:dev-latest
              
  
  # AUTO MERGE DEV → MAIN
 
  auto-merge:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest

    steps:
    - name: Auto merge dev → main
      uses: pascalgn/automerge-action@v0.16.4
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
 
  # Main DEPLOY

  main-deploy:
    if: github.event_name == 'workflow_dispatch'
    runs-on: self-hosted
    environment: production
    
    steps:
      - name: Check branch
        run: |
          if [ "${GITHUB_REF##*/}" != "main" ]; then
            echo "ERROR: Production deploy can only run from the main branch!"
            exit 1
          fi

      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Docker login
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login \
          -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image (main)
        run: |
          docker build \
          -f ${{ inputs.dockerfile }} \
          -t ${{ env.IMAGE_NAME }}:${{ inputs.image_tag }} .

      - name: Push Docker image
        run: |
          docker push ${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}

      - name: Deploy to Production
        run: |
            docker pull ${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}
            docker rm -f ${{ env.DOCKER_CONTAINER_MAIN }} 2>/dev/null || true
            CONTAINERS=$(docker ps -q --filter "publish=8000")
            if [ -n "$CONTAINERS" ]; then
              echo "Stopping containers using port 8000..."
              docker rm -f $CONTAINERS
              sleep 3
            fi
            docker run -d --name ${{ env.DOCKER_CONTAINER_MAIN }} \
            -p 8000:8000 --restart unless-stopped \
            ${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}
